### go实现面向对象编程

go语言中没有类似extends关键字的这种继承的方式，在语言设计上采取的是组合的方式

go的多态是通过接口来实现的

### go的缺点

1、右大括号不允许换行，否则编译报错

2、 不允许有未使用的包或者变量

3、错误处理原始

4、[]interface{}不支持下标操作

5、struct没有构造和解析，资源释放不方便

6、仍然保留C/C++的指针操作，取地址&取值*

### go中的make和new的区别（必问）

***共同点*** ：给变量分配内存

***不同点***： 

1) 作用变量类型不同，new给string，int和数组分配内存，make给切片，map，channnel分配内存

2) 返回的类型不同，new返回变量指针，make返回变量本身

3) new分配的空间清零。make分配的空间会初始化

4) 对于make和new分配的内存，go编译器尽量将变量分配在栈上，如果变量未发生逃逸，那么就会在栈上分配，否则分配在堆上。

> **内存逃逸**简单来讲就是 程序中函数都有自己的局部变量和返回地址空间（栈帧），当某个变量想要在函数结束之后继续使用，需要将其分配到堆上，这种从栈上逃逸到堆上的现象 就是内存逃逸。

## IO多路复用

### for range 的时候它的地址会发生变化么

在for a,b := rang c遍历中，a和b在内存中只会存一份，即每次循环遍历的数据都是以值覆盖的方式赋给a和b，a和b的内存地址始终不变。由于有这个特性，for循环里面如果开协程，不要直接把a或者b的地址传给协程。解决办法就是每次循环时，创建一个临时变量。

### defer的执行顺序

多个defer出现的时候，**它是一个“栈”的关系，也就是先进后出**。一个函数中，写在前面的defer会比写在后面的defer调用的晚。

### defer与return谁先谁后

return之后的语句先执行，defer后的语句后执行

### 函数的返回值初始化

只要声明函数的返回值变量名称，就会在函数初始化时候为之赋值为0，而且在函数体作用域可见

### 有名函数返回值遇见defer情况

在没有defer的情况下，其实函数的返回就是与return一致的，但是有了defer就不一样了。先return，再defer

### defer遇见panic

遇到panic时，遍历本协程的defer链表，并执行defer。在执行defer过程中:遇到recover则停止panic，返回recover处继续往下执行。如果没有遇到recover，遍历完本协程的defer链表后，向stderr抛出panic信息。

> **defer 最大的功能是 panic 后依然有效**
> 所以defer可以保证你的一些资源一定会被关闭，从而避免一些异常出现的问题。

### defer中包含panic

多个panic仅有最后一个可以被revover捕获

### defer总结

defer延迟函数，释放资源，收尾工作；如释放锁，关闭文件，关闭链接；捕获panic;

defer函数紧跟在资源打开后面，否则defer可能得不到执行，导致内存泄露。

多个 defer 调用顺序是 LIFO（后入先出），defer后的操作可以理解为压入栈中

defer，return，return value（函数返回值） 执行顺序：首先return，其次return value，最后defer。defer可以修改函数最终返回值

### uint 类型溢出问题

超过最大存储值如uint8最大是255
var a uint8 =255
var b uint8 =1
a+b = 0总之类型溢出会出现难以意料的事

### **rune 类型**

相当int32
golang中的字符串底层实现是通过byte数组的，中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8
byte 等同于int8，常用来处理ascii字符
rune 等同于int32,常用来处理unicode或utf-8字符

### **golang 中解析 tag 是怎么实现的？反射原理是什么？(中高级肯定会问，比较难，需要自己多去总结)**

go中解析的tag是通过反射来实现的，反射是指计算机程序在运行时（run time）可以访问、检测和修改它本身的状态或行为的一种能力或动态知道给定数据对象的类型和结构，并有机会修改它。反射将接口变量转换成反射对象Type和Value；反射可以通过反射对象Value还原成原先的接口变量；反射可以用来修改一个变量的值，前提是这个值可以被修改；tag是啥：结构体支持标记，name string `json:name-field`就是`json:name-field`这部分。

> gorm Json Yaml gRPC Protobuf Gin.Bind()都是通过反射实现的

### **调用函数传入结构体时，应该传值还是指针？ （Golang 都是传值）**

Go 的函数参数传递都是值传递。所谓值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数

因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。但并不是 map，slice，chan 的所有的变量在函数内都能被修改，不同数据类型的底层存储结构和实现可能不太一样，情况也就不一样。

### goroutine什么情况下会阻塞

1、由原子、互斥量或者通道操作导致阻塞，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine

2、由于网络请求和IO操作导致Goroutine 阻塞，Go 程序提供了网络轮询器（NetPoller）来处理网络请求和 IO 操作的问题，其后台通过 kqueue（MacOS），epoll（Linux）或 iocp（Windows）来实现 IO 多路复用。通过**使用 NetPoller 进行网络系统调用**，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。执行网络系统调用不需要额外的 M，**网络轮询器使用系统线程**，它时刻处理一个有效的事件循环，有助于减少操作系统上的调度负载。用户层眼中看到的 Goroutine 中的“block socket”，实现了 goroutine-per-connection 简单的网络编程模式。实际上是通过 Go runtime 中的 netpoller 通过 Non-block socket + I/O 多路复用机制“模拟”出来的。

3、当调用一些系统方法的时候（如文件 I/O），如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 G1 将阻塞当前 M1。调度器引入 其它M 来服务 M1 的P

4、如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行

**讲讲 Go 的 select 底层数据结构和一些特性？（难点，没有项目经常可能说不清，面试一般会问你项目中怎么使用select）**

go 的 select 为 golang 提供了多路 IO 复用机制，和其他 IO 复用一样，用于检测是否有读写事件是否 ready。linux 的系统 IO 模型有 select，poll，epoll，go 的 select 和 linux 系统 select 非常相似。

select 结构组成主要是由 case 语句和执行的函数组成 select 实现的多路复用是：每个线程或者进程都先到注册和接受的 channel（装置）注册，然后阻塞，然后只有一个线程在运输，当注册的线程和进程准备好数据后，装置会根据注册的信息得到相应的数据

**select 的特性**
1）select 操作至少要有一个 case 语句，出现读写 nil 的 channel 该分支会忽略，在 nil 的 channel 上操作则会报错。
2）select 仅支持管道，而且是单协程操作。
3）每个 case 语句仅能处理一个管道，要么读要么写。
4）多个 case 语句的执行顺序是随机的。
5）存在 default 语句，select 将不会阻塞，但是存在 default 会影响性能。

### **Go 的 defer 底层数据结构和一些特性？**

每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。

**defer 的规则总结**：
延迟函数的参数是 defer 语句出现的时候就已经确定了的。
延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。
延迟函数可能操作主函数的返回值。
申请资源后立即使用 defer 关闭资源是个好习惯。

### **单引号，双引号，反引号的区别？**

单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。

双引号，才是字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。
反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。

### go出现panic的场景

- 数组/切片越界
- 空指针调用。比如访问一个 nil 结构体指针的成员
- 过早关闭 HTTP 响应体
- 除以 0
- 向已经关闭的 channel 发送消息
- 重复关闭 channel
- 关闭未初始化的 channel
- 未初始化 map。注意访问 map 不存在的 key 不会 panic，而是返回 map 类型对应的零值，但是不能直接赋值
- 跨协程的 panic 处理
- sync 计数为负数。
- 类型断言不匹配。`var a interface{} = 1; fmt.Println(a.(string))` 会 panic，建议用 `s,ok := a.(string)`

### go是否支持while循环，如何实现这种机制

go没有while循环，可以通过for if实现while循环

### go里面如何实现set？

Go中是不提供Set类型的，Set是一个集合，其本质就是一个List，只是List里的元素不能重复。

Go提供了map类型，但是我们知道，map类型的key是不能重复的，因此，我们可以利用这一点，来实现一个set。那value呢？value我们可以用一个常量来代替，比如一个空结构体，实际上空结构体不占任何内存，使用空结构体，能够帮我们节省内存空间，提高性能

### 值拷贝 与 引用拷贝，深拷贝 与 浅拷贝

map，slice，chan 是引用拷贝；引用拷贝 是 浅拷贝
其余的，都是 值拷贝；值拷贝 是 深拷贝

#### 深浅拷贝的本质区别：

是否真正获取对象实体，而不是引用
**深拷贝：**
拷贝的是数据本身，创造一个新的对象，并在内存中开辟一个新的内存地址，与原对象是完全独立的，不共享内存，修改新对象时不会影响原对象的值。释放内存时，也没有任何关联。
**值拷贝：**
接收的是 整个array的值拷贝，所以方法对array中元素的重新赋值不起作用。

**浅拷贝：**
拷贝的是数据地址，只复制指向的对象的指针，新旧对象的内存地址是一样的，修改一个另一个也会变。释放内存时，同时释放。
**引用拷贝：**
函数的引用拷贝与原始的引用指向同一个数组，所以对数组中元素的修改，是有效的

### Go 多返回值怎么实现的？

Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。

### Go 语言中不同的类型如何比较是否相等？

像 string，int，float interface 等可以通过 `reflect.DeepEqual` 和等于号进行比较，像 slice，struct，map 则一般使用` reflect.DeepEqual `来检测是否相等。

### Go中init 函数的特征?

一个包下可以有多个 init 函数，每个文件也可以有多个 init 函数。多个 init 函数按照它们的文件名顺序逐个初始化。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。不管包被导入多少次，包内的 init 函数只会执行一次。应用初始化时初始化工作的顺序是，从被导入的最深层包开始进行初始化，层层递出最后到 main 包。但包级别变量的初始化先于包内 init 函数的执行

### Go中 uintptr和 unsafe.Pointer 的区别？

`unsafe.Pointer `是通用指针类型，它不能参与计算，任何类型的指针都可以转化成` unsafe.Pointer`，`unsafe.Pointer` 可以转化成任何类型的指针，`uintptr` 可以转换为 `unsafe.Pointer`，`unsafe.Pointer` 可以转换为 `uintptr`。`uintptr` 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），`unsafe.Pointer `是指针对象进行运算（也就是 `uintptr`）的桥梁。

### 什么是goroutine

1. 定义：
   - goroutine 是 Go 语言中的一种轻量级线程，由 Go 运行时管理。
2. 使用方法：
   - 使用 `go` 关键字启动一个新的 goroutine。例如：`go 函数名(参数列表)`。
3. 优势：
   - goroutine 的创建和销毁开销非常小，可以高效地创建成千上万个 goroutine。
   - goroutine 是并发执行的，可以提高程序的执行效率。
4. 调度：
   - 由 Go 运行时调度和管理，无需手动管理线程。
5. 通信：
   - goroutine 之间通过 channel 进行通信，确保数据传递的安全性和同步性。
6. 典型应用：
   - 适用于并发任务处理，如网络请求处理、并发计算等。
7. 示例：
   - 在 Web 服务器中，每个请求可以由一个单独的 goroutine 处理，从而提高并发处理能力。

### **数组和切片的区别 （基本必问）**

**相同点：**
1)只能存储一组相同类型的数据结构
2)都是通过下标来访问，并且有容量长度，长度通过 len 获取，容量通过 cap 获取
**区别：**
1）数组是定长，访问和复制不能超过数组定义的长度，否则就会下标越界，切片长度和容量可以自动扩容
2）数组是值类型，切片是引用类型，每个切片都引用了一个底层数组，切片本身不能存储任何数据，都是这底层数组存储数据，所以修改切片的时候修改的是底层数组中的数据。切片一旦扩容，指向一个新的底层数组，内存地址也就随之改变
**简洁的回答：**
1）定义方式不一样 2）初始化方式不一样，数组需要指定大小，大小不改变 3）在函数传递中，数组切片都是值传递。

Go 的 slice 底层数据结构是由一个 array 指针指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。

### golang中数组和slice作为参数的区别？slice作为参数传递有什么问题？

1. 当使用数组作为参数和返回值的时候，传进去的是值，在函数内部对数组进行修改并不会影响原数据
2. 当切片作为参数的时候穿进去的是值，也就是值传递，但是当我在函数里面修改切片的时候，我们发现源数据也会被修改，这是因为我们在切片的底层维护这一个匿名的数组，当我们把切片当成参数的时候，会重现创建一个切片，但是创建的这个切片和我们原来的数据是共享数据源的，所以在函数内被修改，源数据也会被修改
3. 数组还是切片，在函数中传递的时候如果没有指定为指针传递的话，都是值传递，但是切片在传递的过程中，有着共享底层数组的风险，所以如果在函数内部进行了更改的时候，会修改到源数据，所以我们需要根据不同的需求来处理，如果我们不希望源数据被修改话的我们可以使用copy函数复制切片后再传入，如果希望源数据被修改的话我们应该使用指针传递的方式

## map相关

### 什么类型可以作为map 的key

在Go语言中，map的key可以是任何可以**比较**的类型。这包括所有的基本类型，如**整数、浮点数、字符串和布尔值，以及结构体和数组**，只要它们没有被定义为包含不可比较的类型（如切片、映射或函数）。

> 切片、映射和函数类型是不可比较的，因此不能作为map的key。如果你需要一个包含这些类型的key，你可以考虑使用一个指向这些类型的指针，或者将它们封装在一个可比较的结构体中，并确保结构体不包含任何不可比较的类型。

### map 使用注意的点，是否并发安全？

#### map使用的注意点



1. **key的唯一性**：map中的每个key必须是唯一的。如果尝试使用已存在的key插入新值，则会覆盖旧值。

2. **key的不可变性**：作为key的类型必须是可比较的，这通常意味着它们应该是不可变的。例如，在Go语言中，切片、映射和函数类型因为包含可变状态，所以不能直接作为map的key。

3. **初始化和nil map**：在Go语言中，声明一个map变量不会自动初始化它。未初始化的map变量的零值是nil，对nil map进行读写操作会引发panic。因此，在使用map之前，应该使用`make`函数进行初始化。

4. **遍历顺序**：map的遍历顺序是不确定的，每次遍历的结果可能不同。如果需要按照特定顺序处理map中的元素，应该先对key进行排序。

   > 如果你需要按照特定的顺序处理map中的元素，你应该先将key提取到一个切片中，对切片进行排序，然后按照排序后的顺序遍历切片，并从map中取出对应的值。这样，你就可以按照特定的顺序处理map中的元素了。

5. **并发安全性**：默认情况下，map并不是并发安全的。在并发环境下对同一个map进行读写操作可能会导致竞态条件和数据不一致性。

#### 并发安全性



**Go语言中的map并发安全性**：

- Go语言中的map类型并不是并发安全的。这意味着，如果有多个goroutine尝试同时读写同一个map，可能会导致竞态条件和数据损坏。
- 为了在并发环境下安全地使用map，可以采取以下几种策略：
  1. **使用互斥锁（sync.Mutex）**：在读写map的操作前后加锁，确保同一时间只有一个goroutine可以访问map。
  2. **使用读写互斥锁（sync.RWMutex）**：如果读操作远多于写操作，可以使用读写锁来提高性能。读写锁允许多个goroutine同时读取map，但在写入时需要独占访问。
  3. **使用并发安全的map（sync.Map）**：从Go 1.9版本开始，标准库中的`sync`包提供了`sync.Map`类型，这是一个专为并发环境设计的map。它提供了一系列方法来安全地在多个goroutine之间共享数据。

结论：

在使用map时，需要注意其key的唯一性和不可变性，以及初始化和并发安全性的问题。特别是在并发环境下，应该采取适当的措施来确保map的安全访问，以避免竞态条件和数据不一致性。在Go语言中，可以通过使用互斥锁、读写互斥锁或并发安全的map（`sync.Map`）来实现这一点。

### map 的数据结构是什么？

golang 中 map 是一个 kv 对集合。底层使用 hash table，用链表来解决冲突 ，出现冲突时，不是每一个 key 都申请一个结构通过链表串起来，而是以 bmap 为最小粒度挂载，一个 bmap 可以放 8 个 kv。在哈希函数的选择上，会在程序启动时，检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。每个 map 的底层结构是 hmap，是有若干个结构为 bmap 的 bucket 组成的数组。每个 bucket 底层都采用链表结构。

## 接口

### go和鸭子类型的关系

总结一下，鸭子类型是一种动态语言的风格，在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它"当前方法和属性的集合"决定。Go 作为一种静态语言，通过接口实现了 鸭子类型，实际上是 Go 的编译器在其中作了隐匿的转换工作。

## context相关

### **context 结构是什么样的？context 使用场景和用途？**

Go 的 Context 的数据结构包含 Deadline，Done，Err，Value。Deadline 方法返回一个 time.Time，表示当前 Context 应该结束的时间，ok 则表示有结束时间，Done 方法当 Context 被取消或者超时时候返回的一个 close 的 channel，告诉给 context 相关的函数要停止当前工作然后返回了，Err 表示 context 被取消的原因，Value 方法表示 context 实现共享数据存储的地方，是协程安全的。context 在业务中是经常被使用的，

**其主要的应用 ：**

1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。

### 常用函数

- `context.Background()`: 返回一个空的 `Context`，通常用于根 `Context`。
- `context.TODO()`: 返回一个空的 `Context`，用于暂时不知道该使用什么 `Context` 的情况。
- `context.WithCancel(parent Context) (Context, CancelFunc)`: 创建一个可以取消的 `Context`。
- `context.WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)`: 创建一个带超时的 `Context`。
- `context.WithDeadline(parent Context, d time.Time) (Context, CancelFunc)`: 创建一个带截止时间的 `Context`。
- `context.WithValue(parent Context, key, val interface{}) Context`: 创建一个携带值的 `Context`。

通过这些功能，`context` 在 Go 中为管理 goroutine 的生命周期和跨 goroutine 传递数据提供了便利和强大的支持。

## **channel相关**

### channel的底层数据结构

channel是go中用来实现多个goroutine通信的管道，它的底层是一个叫做hchan的结构体。在go的runtime包下。

### **channel 是否线程安全？锁用在什么地方？**

1. Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据 都是 原子性的。
2. 而且Go的设计思想就是:***不要通过共享内存来通信，而是通过通信来共享内存**，前者就是传统的加锁，后者就是Channel。
3. 也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的

### **nil、关闭的 channel、有数据的 channel，再进行读、写、关闭会怎么样？（各类变种题型，重要）**

#### Channel读写特性(15字口诀)

首先，我们先复习一下Channel都有哪些特性？

- 给一个 nil channel 发送数据，造成永远阻塞
- 从一个 nil channel 接收数据，造成永远阻塞
- 给一个已经关闭的 channel 发送数据，引起 panic
- 从一个已经关闭的 channel 接收数据，如果缓冲区中为空，则返回一个零值
- 无缓冲的channel是同步的，而有缓冲的channel是非同步的

以上5个特性是死东西，也可以通过口诀来记忆：“空读写阻塞，写关闭异常，读关闭空零”。

### **向 channel 发送数据和从 channel 读数据的流程是什么样的？**

#### 发送流程：

向一个channel中写数据简单过程如下：

1. 如果等待接收队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G,并把数据写入，最后把该G唤醒，结束发送过程；
2. 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程；
3. 如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；

#### 接收流程：

从一个channel读数据简单过程如下：

1. 如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；
2. 如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程；
3. 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；
4. 将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；

#### 关闭channel

关闭channel时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。
除此之外，panic出现的常见场景还有：

1. 关闭值为nil的channel
2. 关闭已经被关闭的channel
3. 向已经关闭的channel写数据

### **讲讲 Go 的 chan 底层数据结构和主要使用场景**

channel 的数据结构包含 qccount 当前队列中剩余元素个数，dataqsiz 环形队列长度，即可以存放的元素个数，buf 环形队列指针，elemsize 每个元素的大小，closed 标识关闭状态，elemtype 元素类型，sendx 队列下表，指示元素写入时存放到队列中的位置，recv 队列下表，指示元素从队列的该位置读出。recvq 等待读消息的 goroutine 队列，sendq 等待写消息的 goroutine 队列，lock 互斥锁，chan 不允许并发读写。

**无缓冲和有缓冲区别：** 管道没有缓冲区，从管道读数据会阻塞，直到有协程向管道中写入数据。同样，向管道写入数据也会阻塞，直到有协程从管道读取数据。管道有缓冲区但缓冲区没有数据，从管道读取数据也会阻塞，直到协程写入数据，如果管道满了，写数据也会阻塞，直到协程从缓冲区读取数据。
**channel 的一些特点** 1）、读写值 nil 管道会永久阻塞 2）、关闭的管道读数据仍然可以读数据 3）、往关闭的管道写数据会 panic 4）、关闭为 nil 的管道 panic 5）、关闭已经关闭的管道 panic
**向 channel 写数据的流程：** 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G,并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒；
**向 channel 读数据的流程：** 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒；
**使用场景：** 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步

### 有缓存channel和无缓存channel

无缓存channel适用于数据要求同步的场景，而有缓存channel适用于无数据同步的场景。可以根据实现项目需求选择。

### channel 在什么情况下会引起资源泄漏

泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。

另外，程序运行过程中，对于一个 channel，如果没有任何 goroutine 引用了，gc 会对其进行回收操作，不会引起内存泄漏

## **GMP相关**

### 什么是 GMP？（必问）

G 代表着 goroutine，P 代表着上下文处理器，M 代表 thread 线程，在 GPM 模型，有一个全局队列（Global Queue）：存放等待运行的 G，还有一个 P 的本地队列：也是存放等待运行的 G，但数量有限，不超过 256 个。

#### 调度流程：

1. 创建 Goroutine：
   - 当通过 `go func()` 创建新的 Goroutine 时，G 会首先被加入到与当前 P 关联的本地队列中。
   - 如果 P 的本地队列已满（超过 256 个 G），则新的 G 会被放入全局队列。
2. 调度与执行：
   - 每个 M 与一个 P 绑定，M 从 P 的本地队列中获取一个 G 来执行。
   - 如果 P 的本地队列为空，M 会尝试从全局队列或其他 P 的本地队列中偷取（work stealing）任务执行。
3. 系统调用与阻塞：
   - 当 G 执行过程中发生阻塞或系统调用，M 也会被阻塞。这时，P 会解绑当前的 M，并尝试寻找或创建新的 M 来继续执行其他 G。
   - 阻塞结束后，原来的 M 会尝试重新绑定一个 P 继续执行。

#### G,P,M 的个数问题：

**G（Goroutine）的个数**

- **理论上无限制**：G的数量在理论上是没有上限的，只要系统的内存足够，就可以创建大量的goroutine。这是因为goroutine比线程更轻量级，它们共享相同的地址空间，并且在堆上分配的内存相对较少。
- **实际受内存限制**：尽管理论上goroutine的数量没有限制，但实际上它们会受到系统可用内存的限制。每个goroutine都需要分配一定的栈空间（尽管栈的大小可以动态调整），而且goroutine之间共享的数据结构（如全局变量、通道等）也会占用内存。

**P（Processor）的个数**

- **通常设置为逻辑CPU数的两倍**：P的数量通常建议设置为逻辑CPU核心数的两倍，这是为了提高调度的并行性和效率。每个P都可以绑定到一个M上执行goroutine，而设置更多的P可以使得在某些M阻塞时，其他M仍然可以执行P上的goroutine，从而减少等待时间。
- **由**`GOMAXPROCS`**决定**：P的实际数量由环境变量`GOMAXPROCS`（或在Go程序中通过`runtime.GOMAXPROCS`函数设置）决定。这个值限制了同时运行的goroutine的数量，即在任何给定时间，最多只有`GOMAXPROCS`个goroutine在CPU上执行。

**M（Machine/Thread）的个数**

- **动态创建和销毁**：M的数量是动态变化的，Go运行时根据需要创建和销毁M。当一个M上的所有goroutine都阻塞时，该M可能会被销毁，而当有goroutine等待执行但没有可用的M时，会创建新的M。
- **默认和最大限制**：Go程序启动时，会设置一个M的最大数量（默认通常是10000，但这个值可能因Go版本和操作系统而异），但这个限制很少达到，因为操作系统本身就有线程/进程数量的限制。此外，通过`runtime/debug`包中的`SetMaxThreads`函数可以设置M的最大数量，但这个函数主要用于调试目的，不建议在生产环境中随意更改。
- **与P的关系**：M与P之间没有绝对的固定关系。一个M可以绑定到任意P上执行goroutine，而当M阻塞时，它会释放其绑定的P，P随后会尝试绑定到其他空闲的M上。因此，即使P的数量较少，也可能因为工作量窃取和M的动态创建而有大量的M存在（尽管这些M中的大多数可能在等待中）。

#### 关键机制

**work stealing（工作量窃取） 机制**：会优先从全局队列里进行窃取，之后会从其它的P队列里窃取一半的G，放入到本地P队列里。
**hand off （移交）机制**：M 被阻塞时，P 会被移交给其他空闲的 M，或者创建新的 M 来执行任务。

### 进程、线程、协程有什么区别？（必问）

进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。
线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。
协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行

## 锁相关

### 除了 mutex 以外还有那些方式安全读写共享变量？

- 将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过 channel 进行读写操作。
- 可以用个数为 1 的信号量（semaphore）实现互斥
- 通过 Mutex 锁实现

### Go 如何实现原子操作？

原子操作就是不可中断的操作，外界是看不到原子操作的中间状态，要么看到原子操作已经完成，要么看到原子操作已经结束。在某个值的原子操作执行的过程中，CPU 绝对不会再去执行其他针对该值的操作，那么其他操作也是原子操作。

**原子操作与互斥锁的区别**
1）、互斥锁是一种数据结构，用来让一个线程执行程序的关键部分，完成互斥的多个操作。
2）、原子操作是针对某个值的单个互斥操作。

### Mutex 是悲观锁还是乐观锁？悲观锁、乐观锁是什么？

**悲观锁**
悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。
**乐观锁**
乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果冲突，则返回给用户异常信息，让用户决定如何去做。乐观锁适用于读多写少的场景，这样可以提高程序的吞吐量

### Mutex 有几种模式？

**1）正常模式**

1. 当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。
2. 新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。
3. 新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。

**2）饥饿模式**
在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:

1. 此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；
2. 此 waiter 的等待时间小于 1 毫秒。

### sync.Mutex

`sync.Mutex` 是 Go 语言标准库 `sync` 包中的一个互斥锁类型，用于在多个 goroutine 之间同步对共享资源的访问。当多个 goroutine 需要访问同一个资源时，使用 `sync.Mutex` 可以确保在任何时刻只有一个 goroutine 能够访问该资源，从而避免数据竞争和不一致性的问题。

**主要特点**

- **互斥性**：在任何时刻，只有一个 goroutine 可以持有 `sync.Mutex` 的锁。如果多个 goroutine 尝试同时获取锁，那么除了第一个成功获取锁的 goroutine 之外，其他 goroutine 将被阻塞，直到锁被释放。
- **非重入性**：如果一个 goroutine 已经持有了`sync.Mutex `的锁，那么它不能再次请求这个锁，这会导致死锁。

**使用场景**

`sync.Mutex`适用于需要严格互斥访问共享资源的场景。例如，在并发编程中，如果有多个 goroutine 需要修改同一个数据结构或访问同一个文件

### sync.RWMutex

与普通的互斥锁相比`sync.RWMutex`允许多个读操作同时进行，但写操作会完全互斥。这意味着在任何时刻，可以有多个 goroutine 同时读取某个资源，但写入资源时，必须保证没有其他 goroutine 在读取或写入该资源。

**主要特点**

- **多个读者，单一写者**：允许多个读操作并发执行，但写操作会阻塞所有其他读写操作。
- **优化读性能**：通过允许多个读操作同时进行，提高了读操作的并发性能。
- **写操作独占性**：写操作在执行时会阻止所有其他读写操作，确保数据的一致性和完整性。

**使用场景**

适用于读多写少的场景，可以显著提高程序的并发性能。例如，在缓存系统、配置管理系统等场景中，读操作远多于写操作

### 什么是自旋锁

旋锁是指当一个线程（在 Go 中是 Goroutine）在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待（自旋），不断判断锁是否已经被释放，而不是进入睡眠状态。这种行为在某些情况下可能会导致资源的过度占用，特别是当锁持有时间较长或者自旋的 Goroutine 数量较多时。

旋锁的**核心思想**是，如果预期锁很快就会被释放（即锁持有时间很短），那么让线程持续运行并检查锁的状态，而不是进入睡眠和唤醒的昂贵操作，可能会更加高效。然而，如果锁被长时间持有，或者多个线程同时竞争锁，自旋锁可能会导致大量的CPU时间被浪费在无效的循环等待上，这种情况称为“自旋”。

## **并发相关**

### Go 中主协程如何等待其余协程退出?

Go 的 sync.WaitGroup 是等待一组协程结束，sync.WaitGroup 只有 3 个方法，Add()是添加计数，Done()减去一个计数，Wait()阻塞直到所有的任务完成。Go 里面还能通过有缓冲的 channel 实现其阻塞等待一组协程结束，这个不能保证一组 goroutine 按照顺序执行，可以并发执行协程。Go 里面能通过无缓冲的 channel 实现其阻塞等待一组协程结束，这个能保证一组 goroutine 按照顺序执行，但是不能并发执行。

### 怎么控制并发数？

**有缓冲通道**

根据通道中没有数据时读取操作陷入阻塞和通道已满时继续写入操作陷入阻塞的特性，正好实现控制并发数量。

### 多个 goroutine 对同一个 map 写会 panic，异常是否可以用 defer 捕获？

可以捕获异常，但是只能捕获一次

## **垃圾回收-GC**

- **算法**：Golang采用三色标记清扫法进行垃圾回收，以减少STW（Stop The World）的时间。**写屏障技术**被用来避免在并发标记过程中产生的误清扫问题。
- **触发条件**：垃圾回收的触发条件包括内存分配达到一定比例、长时间未触发GC、手动调用runtime.GC()等。

### GC 算法有四种:

- 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象。
  - 优点：对象可以很快地被回收，不会出现内存耗尽或达到某个阀值时才回收。
  - 缺点：不能很好地处理循环引用，而且实时维护引用计数，也有一定的代价。
  - 代表语言：Python、PHP、Swift
- 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为”被引用”，没有被标记的进行回收。
  - 优点：解决了引用计数的缺点。
  - 缺点：需要STW，即要暂时停掉程序运行。
  - 代表语言：Golang（其采用三色标记法）
- 节点复制：节点复制也是基于追踪的算法。其将整个堆等分为两个半区（semi-space），一个包含现有数据，另一个包含已被废弃的数据。节点复制式垃圾收集从切换（flip）两个半区的角色开始，然后收集器在老的半区，也就是 Fromspace 中遍历存活的数据结构，在第一次访问某个单元时把它复制到新半区，也就是 Tospace 中去。 在 Fromspace 中所有存活单元都被访问过之后，收集器在 Tospace 中建立一个存活数据结构的副本，用户程序可以重新开始运行了。
  - 优点：
    - 所有存活的数据结构都缩并地排列在 Tospace 的底部，这样就不会存在内存碎片的问题
    - 获取新内存可以简单地通过递增自由空间指针来实现。
  - 缺点：内存得不到充分利用，总有一半的内存空间处于浪费状态。
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率。
  - 优点：回收性能好
  - 缺点：算法复杂
  - 代表语言： JAVA

### 三色标记法的流程

#### 为什么需要三色标记？

**三色标记的目的**：

1. 主要是利用Tracing GC(Tracing GC 是垃圾回收的一个大类，另外一个大类是引用计数) 做增量式垃圾回收，降低最大暂停时间。
2. 原生Tracing GC只有黑色和白色，没有中间的状态，这就要求GC扫描过程必须一次性完成，得到最后的黑色和白色对象。在前面增量式GC中介绍到了，这种方式会存在较大的暂停时间。
3. 三色标记增加了中间状态灰色，增量式GC运行过程中，应用线程的运行可能改变了对象引用树，只要让黑色对象直接引用白色对象，GC就可以增量式的运行，减少停顿时间。

#### 什么是三色标记？

三色标记，通过字面意思我们就可以知道它由3种颜色组成：

1. **黑色** Black：表示对象是可达的，即使用中的对象，黑色是已经被扫描的对象。
2. **灰色** Gary：表示被黑色对象直接引用的对象，但还没对它进行扫描。
3. **白色** White：白色是对象的初始颜色，如果扫描完成后，对象依然还是白色的，说明此对象是垃圾对象。

#### 三色标记规则

黑色不能指向白色对象。即黑色可以指向灰色，灰色可以指向白色。

**三色标记算法是对标记阶段的改进，原理如下：**

- **起初所有对象都是白色。**
- **从根出发扫描所有可达对象，标记为灰色，放入待处理队列。**
- **从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。**
- **重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。**

## 框架

### Gin

#### 理解

1. Gin 是一个用 Go 语言编写的轻量级 Web 框架，专注于高效的 HTTP 路由和中间件管理。它以简洁易用的 API 和极高的性能著称，适合开发 RESTful API 和 Web 服务。
2. Gin 的**核心是路由机制**，通过将 HTTP 请求路由到相应的处理函数来实现。它支持路由分组，便于组织和管理复杂的路由结构。
3. 同时，Gin 提供了一套强大的中间件机制，允许在请求到达处理函数之前进行预处理，如日志记录、认证、错误处理等。
4. Gin 的**另一个亮点是它的 JSON 解析和响应处理能力**，通过内置的 `c.JSON` 方法，可以轻松地将数据结构序列化为 JSON 格式返回给客户端。

总的来说，Gin 适合用于开发性能要求高的 Web 应用，尤其是对于需要处理大量并发请求的场景。

**Gin 框架的请求处理过程大致分为以下几个步骤：**

1. **请求接收**：
   当 HTTP 请求到达 Gin 应用时，Gin 框架会首先接收到请求。这些请求会被 `gin.Engine` 对象处理，`Engine` 是 Gin 的核心组件。
2. **路由匹配**：
   Gin 根据请求的 URL 和 HTTP 方法（如 GET、POST）来匹配路由。框架会查找定义的路由规则，并找到与请求最匹配的处理函数（Handler）。
3. **中间件处理**：
   在执行路由处理函数之前，Gin 会依次执行与该路由关联的中间件。中间件可以用于请求的预处理，如认证、日志记录等。
4. **执行处理函数**：
   中间件执行完毕后，Gin 会调用匹配的路由处理函数。处理函数可以访问请求数据、处理业务逻辑，并准备响应数据。
5. **生成响应**：
   处理函数会通过 `gin.Context` 对象生成响应。可以设置响应状态码、响应头以及响应体。Gin 提供了多种方法来构造响应，比如 `c.String()`、`c.JSON()`、`c.XML()` 等。
6. **响应返回**：
   最终，Gin 将响应数据发送回客户端，完成请求-响应周期。